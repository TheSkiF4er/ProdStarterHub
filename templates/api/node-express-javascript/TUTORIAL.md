# PRODSTARTER.NODE.EXPRESS — TUTORIAL

This tutorial walks engineers through creating, running, testing, and deploying a service scaffolded from the `node-express-javascript` template in **ProdStarterHub**. It focuses on production-ready practices: configuration, containerization, migrations, background processing, observability, and CI/CD.

> Audience: backend engineers, DevOps engineers, and technical leads who will build and operate Node.js + Express microservices.

---

## Table of contents

1. [Prerequisites](#prerequisites)
2. [Get the template & scaffold a project](#get-the-template--scaffold-a-project)
3. [Project layout overview](#project-layout-overview)
4. [Configuration & environment variables](#configuration--environment-variables)
5. [Run locally (dev)](#run-locally-dev)
6. [Run with Docker & docker-compose](#run-with-docker--docker-compose)
7. [Database, migrations & schema changes](#database-migrations--schema-changes)
8. [Background processing & queues (BullMQ example)](#background-processing--queues-bullmq-example)
9. [Health checks, readiness & liveness](#health-checks-readiness--liveness)
10. [Metrics, logging & tracing (observability)](#metrics-logging--tracing-observability)
11. [Testing strategy and examples](#testing-strategy-and-examples)
12. [CI/CD recommendations (GitHub Actions example)](#cicd-recommendations-github-actions-example)
13. [Kubernetes deployment guidance](#kubernetes-deployment-guidance)
14. [Security checklist for production](#security-checklist-for-production)
15. [Troubleshooting & FAQ](#troubleshooting--faq)
16. [Next steps & extension points](#next-steps--extension-points)

---

## Prerequisites

* Node.js 18+ (recommend 18 or 20 LTS). Use `nvm` or `.nvmrc` to manage versions.
* Docker & docker-compose for containerized local stacks
* Git
* A Postgres or MongoDB instance (local Docker compose or cloud)
* Redis for caching and as a broker (for BullMQ)
* Optional: Kubernetes (minikube/kind) for cluster testing

## Get the template & scaffold a project

1. Clone the repository or download the template folder:

```bash
git clone https://github.com/TheSkiF4er/ProdStarterHub.git
cd ProdStarterHub/templates/api/node-express-javascript
```

2. Copy the template into a working directory and initialize a git repo:

```bash
cp -R . ~/projects/my-express-service
cd ~/projects/my-express-service
# Optionally replace tokens (project name) using your editor or a small script
```

3. Install dependencies (see `package.json` generated by the template):

```bash
npm ci
# or
pnpm install
# or
yarn install
```

## Project layout overview

```
project_root/
├── src/
│   ├── index.js            # app entrypoint (createApp/start/shutdown)
│   ├── app/                # routers, controllers, services
│   ├── middleware/         # correlation id, logging, validation
│   ├── db/                 # db client adapters
│   ├── workers/            # background workers and jobs
│   └── utils/              # helpers and error types
├── test/                   # unit & integration tests
├── docker-compose.yml
├── Dockerfile
├── openapi.json            # optional
├── .env.example
├── package.json
├── ARCHITECTURE.md
├── TUTORIAL.md
├── TASKS.md
└── README.md
```

Notes:

* The template uses an app-factory pattern (`createApp`) to make tests deterministic and to allow programmatic lifecycle control.
* Keep `src/` as the primary source to simplify Docker and CI paths.

## Configuration & environment variables

Configuration is environment-driven. A `.env.example` lists variables used by the template. Key variables:

* `NODE_ENV` — `development` / `production` / `test`
* `PORT` — HTTP port (default 3000)
* `SERVICE_NAME` — used in logs and metrics
* `DATABASE_DSN` — canonical DB connection string (Postgres, Mongo)
* `REDIS_URL` — Redis connection for cache and queue
* `CORS_ORIGINS` — comma-separated allowed origins
* `SWAGGER_ENABLED` — `true` to enable Swagger UI (dev only)
* `LOG_LEVEL` — log level (info/debug)
* `RATE_LIMIT_MAX` / `RATE_LIMIT_WINDOW_MS` — rate limit tuning

Use a `.env` file for local development (never commit it) and platform secret stores for production.

## Run locally (dev)

1. Install deps: `npm ci`
2. Start supporting services (Postgres, Redis) via docker-compose or local installs
3. Start the app in development mode:

```bash
# Using nodemon (dev)
npm run start:dev

# Or directly
node src/index.js
```

Visit:

* API root: `http://localhost:3000/api/v1/`
* Health: `http://localhost:3000/health`
* Swagger UI: `http://localhost:3000/docs` (when enabled)

## Run with Docker & docker-compose

The template includes a multi-service `docker-compose.yml` for local development (app + Postgres + Redis). Example:

```bash
docker-compose up --build
# Run migrations inside the app container if needed
docker-compose exec app npm run migrate
```

Stop & remove volumes:

```bash
docker-compose down -v
```

Dockerfile notes:

* Uses multi-stage build to install dependencies and produce a small runtime image
* Runs as non-root user in final stage
* Exposes `PORT` and provides a healthcheck that maps to `/ready` or `/health`

## Database, migrations & schema changes

* Use `knex`, `sequelize`, or `umzug` for relational DB migrations, or `migrate-mongo` for MongoDB.
* Keep migration files checked into VCS and run migrations in CI or as a pre-deploy job.

**Recommended migration strategy**

1. Create new migration SQL / JS and commit to repo.
2. Run migration in a controlled environment (CI/job) before routing traffic to the new release.
3. For destructive changes, use multi-release strategy: add new column, deploy code using both columns, backfill, switch reads, then drop old column later.

## Background processing & queues (BullMQ example)

This template includes scaffolding for background workers using **BullMQ** (Redis-backed). Guidelines:

* Run workers as separate processes or Kubernetes deployments to scale independently from web.
* Design tasks to be idempotent and safe to retry.
* Use Redis for rate limiting, locks, and queues; monitor queue length and failure metrics.

Start a worker locally (example):

```bash
# in separate terminal
npm run worker
```

Best practices:

* Use separate Redis DB instances for caching and queues in production.
* Configure a Dead-Letter Queue (DLQ) for failed tasks after N retries.
* Export worker metrics and monitor with Prometheus/Grafana.

## Health checks, readiness & liveness

Template exposes three endpoints:

* `GET /live` — liveness probe (process is running)
* `GET /ready` — readiness probe (app can accept traffic; DB and Redis checks)
* `GET /health` — composite health with dependency checks and short uptime metrics

Integrate these endpoints with your orchestrator’s probes (Kubernetes readiness/liveness) to prevent traffic to unhealthy instances.

## Metrics, logging & tracing (observability)

### Logging

* Structured JSON logs using `pino`; logs to stdout for ingestion into ELK/Loki/Datadog.
* Include `service`, `environment`, and `request_id` in logs.

### Metrics

* Prometheus client (`prom-client`) exposes default Node metrics plus request counters and histograms.
* Expose `/metrics` and protect it from public access in production (use network policies or auth).

### Tracing

* Add OpenTelemetry Node SDK and auto-instrumentation for HTTP, Redis, and DB clients.
* Configure OTLP exporter to send traces to your collector (Jaeger/OTLP).

### Correlation IDs

* Middleware sets/propagates `X-Request-Id`. Use the same header to correlate traces, logs and metrics.

## Testing strategy and examples

### Unit tests

* Use `jest` for unit tests. Keep them fast and isolated.

### Integration tests

* Run integration tests against a Testcontainers-managed Postgres/Redis or a docker-compose test stack.
* Use `supertest` to test HTTP routes programmatically.

Example `supertest` snippet:

```js
const request = require('supertest')
const { createApp } = require('../src/index')

describe('GET /api/v1/', () => {
  it('returns 200', async () => {
    const app = createApp()
    const res = await request(app).get('/api/v1/')
    expect(res.statusCode).toBe(200)
  })
})
```

### E2E smoke tests

* CI job that spins the built image, waits for `/ready`, calls health and core endpoints, then tears down.

## CI/CD recommendations (GitHub Actions example)

Recommended workflow:

1. Lint and format checks (`eslint`, `prettier`).
2. Unit tests (jest) and optional integration tests on PRs.
3. Build Docker image and push to registry on `main` or tags.
4. Deploy to staging and run smoke tests.
5. Promote same image to production (canary/blue-green) and run post-deploy checks.

High-level `build-and-publish` job snippet:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node
        uses: actions/setup-node@v4
        with: node-version: '18'
      - name: Install
        run: npm ci
      - name: Lint
        run: npm run lint
      - name: Test
        run: npm test -- --coverage
      - name: Build and push image
        uses: docker/build-push-action@v3
        with:
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/my-express-service:sha-${{ github.sha }}
```

## Kubernetes deployment guidance

* Use `Deployment` + `Service` + `Ingress` (TLS) or an API Gateway.
* Configure `readinessProbe` -> `/ready` and `livenessProbe` -> `/live`.
* Run migrations as a Job before upgrading Deployments.
* Use resource `requests`/`limits`, PodDisruptionBudget, and HPA for autoscaling.
* Keep metrics and tracing collectors (Prometheus, OTEL collector) available in the cluster.

Example readiness probe snippet:

```yaml
readinessProbe:
  httpGet:
    path: /ready
    port: 3000
  initialDelaySeconds: 5
  periodSeconds: 10
```

## Security checklist for production

* Never commit secrets. Use K8s Secrets, Vault, or cloud secret managers.
* `NODE_ENV=production`, `SWAGGER_ENABLED=false` in production.
* Restrict `/metrics` scraping to internal networks.
* Use HTTPS at the edge; enable HSTS and secure cookies if applicable.
* Enforce rate limiting and request size limits.
* Run dependency scans (Snyk/Dependabot) and patch critical vulnerabilities promptly.
* Harden container images and run as non-root user.

## Troubleshooting & FAQ

**App won't start in Docker**

* Check `docker-compose logs app` and verify required env vars are present.

**/ready returns 503**

* Check DB and Redis connectivity. Confirm correct DSNs and that services are reachable inside the network.

**High latency under load**

* Profile DB queries, increase connection pool size, add caching, and consider rate limiting or backpressure.

**Background jobs failing**

* Check Redis availability, inspect job retry policy, and monitor DLQ for poisoned tasks.

## Next steps & extension points

* Add OpenTelemetry automatic instrumentation and provide OTLP collector config.
* Provide a TypeScript variant of the template for stricter typing.
* Add example Helm chart and Kustomize overlays for multi-environment deployments.
* Add library-specific clients (S3 upload helper, feature flag SDK) and example integrations.
