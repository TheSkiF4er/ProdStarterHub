# ProdStarter — C# CLI Tool

[![License](https://img.shields.io/badge/license-Apache--2.0-blue.svg)](LICENSE)

> Production-ready C# CLI template built on top of `System.CommandLine` and the .NET Generic Host. Batteries-included scaffolding for DI, structured logging (Serilog), hosted services, configuration, testing, containerization, and CI/CD.

---

## Contents

* Quickstart
* Highlights & features
* Project layout
* Prerequisites
* Build & run (development and publish)
* Configuration & precedence
* Commands & examples
* Logging, telemetry & diagnostics
* Testing & quality gates
* Docker & reproducible builds
* CI/CD recommendations
* Packaging, releases & distribution
* Contributing
* License

---

## Quickstart

```bash
# copy the template and open the directory
cp -R ProdStarterHub/templates/cli/csharp-cli-tool ~/projects/my-cli
cd ~/projects/my-cli

# restore and build with pinned SDK (use global.json if present)
dotnet restore
dotnet build -c Release

# run the tool (command mode)
dotnet run --project src/ProdStarter.Cli -- run --input ./payload.json
```

To produce a single-file, self-contained binary for Linux:

```bash
dotnet publish src/ProdStarter.Cli -c Release -r linux-x64 --self-contained true -p:PublishSingleFile=true -o ./dist/linux-x64
```

---

## Highlights & features

* Modern CLI powered by `System.CommandLine` with subcommands, options, and autogenerated help.
* Generic Host integration (`Microsoft.Extensions.Hosting`) for DI, configuration, logging and hosted services.
* Serilog structured logging bootstrapped with sensible defaults and environment-driven overrides.
* Optional background worker mode (hosted services) for queue consumers, schedulers and long-running tasks.
* Typed configuration (`IOptions<T>`) with support for appsettings, env vars, command line, and external files.
* Reproducible Docker multi-stage builds and CI templates for publishing artifacts.
* Test scaffolding (xUnit) and guidance for integration tests and smoke tests.
* Template metadata (`template.json`) for easy scaffolding and parameterization.

---

## Project layout

```
src/ProdStarter.Cli/            # main project (replace tokens when scaffolding)
  ├─ Program.cs                 # host bootstrap and System.CommandLine wiring
  ├─ AppOptions.cs               # typed configuration classes
  ├─ Commands/                   # command handlers (Run, Version, Worker...)
  ├─ Services/                   # business logic and DI services
  ├─ Hosted/                     # long-running BackgroundService implementations
  └─ Infra/                      # HttpClient factories, DB adapters, etc.

tests/                          # unit and integration tests
Dockerfile                      # multi-stage reproducible build
.github/workflows/              # CI templates (if enabled)
README.md
ARCHITECTURE.md
TUTORIAL.md
TASKS.md
template.json
```

---

## Prerequisites

* .NET SDK (recommended version pinned in `global.json`, e.g., .NET 8). Install from Microsoft.
* `dotnet` CLI available in PATH.
* Git and a code editor (VS Code / Visual Studio / Rider).
* Docker for reproducible builds (optional).

---

## Build & run

### Local development

```bash
# restore dependencies
dotnet restore

# build
dotnet build -c Debug

# run with dotnet run (command-mode example)
dotnet run --project src/ProdStarter.Cli -- run --input ./payload.json
```

### Publish (self-contained single-file)

```bash
# publish for linux-x64 - self-contained single file
dotnet publish src/ProdStarter.Cli -c Release -r linux-x64 --self-contained true -p:PublishSingleFile=true -o ./dist/linux-x64
```

### Runtime flags

* `--verbose` / `-v` — increase log verbosity
* `--config <path>` — path to additional configuration file (JSON or key-value)
* `--help` — show help and examples for commands

---

## Configuration & precedence

Configuration in the template follows a deterministic precedence (highest → lowest):

1. Command-line options
2. Explicit config file passed via `--config`
3. Environment variables (configurable prefix, e.g., `PRODSTARTER_`)
4. `appsettings.{Environment}.json` and `appsettings.json`

Use typed `IOptions<T>` and validation attributes for configuration safety. Keep secrets out of repository; use user-secrets for local development and a secret manager (Vault, Azure Key Vault, AWS Secrets Manager) in production.

---

## Commands & examples

The template provides common commands and a simple pattern for adding more.

* `run` — main processing command. Supports `--input` and `--dry-run`.
* `worker` — run background hosted services until cancelled (useful for queue consumers).
* `version` — print application version.

Examples:

```bash
# run processing in dry-run mode
./mycli run --input ./data.json --dry-run

# start worker mode (long running)
./mycli worker

# get semver
./mycli version
```

Commands are implemented as DI-resolved handlers for testability.

---

## Logging, telemetry & diagnostics

* Serilog is configured in `Program.cs` to read settings from configuration and environment.
* Use structured JSON logs in production and human-readable console logs in development.
* Correlation IDs and essential properties (`Application`, `Environment`) are attached to logs.
* Optional OpenTelemetry bootstrap points are present (enable via feature flag) to export traces and metrics to an OTLP collector.

---

## Testing & quality gates

* Unit tests scaffolded with xUnit. Mock dependencies with `Moq` or `NSubstitute`.
* Integration tests should use ephemeral services (Testcontainers) when validating external integrations.
* CI must run `dotnet format` (check), analyzers, unit/integration tests and security scans before merging.
* Add smoke tests to validate that published artifacts behave as expected.

---

## Docker & reproducible builds

A multi-stage Dockerfile is included:

1. SDK stage — restores, builds and publishes the app.
2. Runtime stage — copies the published output to a minimal runtime image.

Build and extract binary:

```bash
docker build -t mycli:build .
docker create --name tmp mycli:build
docker cp tmp:/app/mycli ./dist/mycli
docker rm tmp
```

Build in CI inside the SDK image to ensure reproducible toolchain and consistent artifacts.

---

## CI/CD recommendations

* PR pipeline: restore, build, format check, static analyzers and unit tests.
* Release pipeline: publish self-contained artifacts for target RIDs, run integration/smoke tests, run SCA and sign artifacts, publish to GitHub Releases or internal registry.
* Use pinned SDK (`global.json`) for deterministic builds.
* Store secrets in CI secret store; do not expose them in logs.

---

## Packaging & releases

* Publish self-contained single-file artifacts for supported platforms (linux-x64, linux-arm64, win-x64, osx-x64) if distribution simplicity is required.
* Produce checksums (SHA256) and optionally GPG signatures for release artifacts.
* Include `README`, `USAGE`, `LICENSE` and `CHANGELOG` inside release bundles.

---

## Contributing

Contributions welcome. Suggested flow:

1. Fork the repository and create a branch for your feature/bugfix.
2. Run linters and tests locally: `dotnet format`, `dotnet build`, `dotnet test`.
3. Open a PR and reference relevant items in `TASKS.md`.
4. Ensure CI passes and address review comments.

Please follow the coding style, include unit tests for new features, and update documentation when behavior changes.

---

## License

This template is provided under the Apache-2.0 License. See the `LICENSE` file for details.
