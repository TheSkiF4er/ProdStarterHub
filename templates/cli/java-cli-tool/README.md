# ProdStarter — Java CLI Tool

[![License: Apache-2.0](https://img.shields.io/badge/license-Apache--2.0-blue.svg)](LICENSE)

> Production-ready Java CLI template powered by **Picocli** and SLF4J. Batteries-included scaffolding for configuration, structured logging, graceful shutdown, metrics/health probes, testing, reproducible builds and packaging.

---

## Contents

* Quickstart
* Highlights & features
* Project layout
* Prerequisites
* Build & run (Maven & Gradle)
* Configuration & precedence
* Commands & examples
* Logging, metrics & health
* Testing & quality gates
* Packaging, distribution & release
* Docker & reproducible builds
* CI/CD recommendations
* Contributing
* License

---

## Quickstart

```bash
# copy template into your workspace
cp -R ProdStarterHub/templates/cli/java-cli-tool ~/projects/my-tool
cd ~/projects/my-tool

# (if using Maven)
./mvnw -q -DskipTests package
# run
java -jar target/my-tool-1.0.0.jar --help

# (if using Gradle with wrapper)
./gradlew --quiet assemble
java -jar build/libs/my-tool-all.jar --help
```

Replace package, groupId and artifactId as needed before the first build (or use the template tooling to do replacements defined in `template.json`).

---

## Highlights & features

* Picocli-based CLI with subcommands, autogenerated help and completion support.
* SLF4J API for logging with recommendations for Logback or Log4j2 implementations.
* Lightweight built-in metrics and health endpoints (no heavy runtime required).
* Graceful shutdown via JVM shutdown hooks and cancellable flows.
* Clear, documented exit codes for automation.
* Opinionated `ARCHITECTURE.md`, `TUTORIAL.md`, and `TASKS.md` to accelerate production readiness.
* Template metadata (`template.json`) to parameterize scaffolding (package, build tool, Java version).

---

## Project layout

```
src/
  main/
    java/
      com/yourorg/                # replace package as required
        Tool.java                 # entrypoint and subcommands
        commands/                 # optional command classes
        service/                  # business logic
        infra/                    # adapters (http, db)
  test/
pom.xml or build.gradle
Dockerfile
README.md
ARCHITECTURE.md
TUTORIAL.md
TASKS.md
template.json
```

Keep Program/Tool class minimal: bootstrap config & logging, register commands, and delegate to services.

---

## Prerequisites

* JDK 17+ (recommend LTS such as 17 or 21). Pin the JDK in CI and developer docs.
* Maven (3.8+) or Gradle (7+) if you don't rely on the provided wrappers.
* Git and Docker (optional) for image-based reproducible builds.
* IDE: IntelliJ IDEA recommended for Java development.

---

## Build & run

### Maven (recommended default)

```bash
# build (with wrapper if included)
./mvnw -DskipTests=false clean verify

# build fat jar
./mvnw -DskipTests=true package
java -jar target/my-tool-1.0.0.jar run --input data.json
```

### Gradle (alternative)

```bash
# build and test
./gradlew clean check

# build shadow (fat) jar
./gradlew shadowJar
java -jar build/libs/my-tool-all.jar run --input data.json
```

### Build-time metadata

Embed build metadata during packaging (version, commit, build time) into manifest or system properties so `version` subcommand can print them.

---

## Configuration & precedence

Configuration follows deterministic precedence (highest → lowest):

1. Command-line flags (Picocli options)
2. Explicit config file passed via `--config` (properties or YAML)
3. Environment variables (e.g. `PROD_`, `APP_` prefixes)
4. Defaults in code

Keep secrets out of VCS — use environment variables or dedicated secret stores (Vault, cloud secret managers) in production.

---

## Commands & examples

Out of the box the template includes common commands and patterns:

* `run` — main processing pipeline (`--input`, `--dry-run`).
* `config` — print effective configuration (helps debugging env/config merges).
* `version` — display build/version metadata.
* `serve-metrics` — serve `/metrics`, `/ready`, `/live` for Prometheus and orchestrators.

Examples:

```bash
# run a dry-run processing
java -jar target/my-tool-1.0.0.jar run --input payload.json --dry-run

# start a metrics server
java -jar target/my-tool-1.0.0.jar serve-metrics --listen 0.0.0.0:9090

# print effective configuration
java -jar target/my-tool-1.0.0.jar config configs/development.properties
```

Commands should return documented exit codes so scripts and orchestration systems can react deterministically.

---

## Logging, metrics & health

* **Logging:** Use SLF4J API and provide an implementation (Logback recommended). Use human-readable logs in development and JSON in production.
* **Metrics:** Lightweight metrics endpoint is available via `serve-metrics`. For worker processes, expose counters/histograms for task counts and latencies.
* **Health probes:** `/ready` should indicate readiness to receive traffic; `/live` should indicate process liveness.

---

## Testing & quality gates

* Unit tests: JUnit 5 + Mockito for service-level unit tests.
* Integration tests: use Testcontainers for any external dependencies (DB, message brokers).
* Static analysis: run SpotBugs/Checkstyle/PMD and code formatting checks as part of CI.
* Security: enable SCA in CI (Dependabot/Snyk) and review results before release.

Make tests fast and deterministic; keep integration-heavy suites optional in PR-level CI if they are slow.

---

## Packaging & distribution

Release artifacts commonly produced:

* **Fat JAR**: `my-tool-1.2.3.jar` (simple distribution using `java -jar`).
* **Tarball**: `my-tool-1.2.3-linux-x64.tar.gz` containing binary artifacts and docs.
* **Container image**: multi-stage Docker image with a minimal JRE or distroless base.
* **Native image (optional)**: GraalVM native-image for ultra-fast startup (requires additional testing and support).

Include SHA256 checksums and optional GPG signatures with releases.

---

## Docker & reproducible builds

Provide a multi-stage Dockerfile to build with a stable build image (maven/gradle) and produce a small runtime image.

High-level pattern:

1. Builder stage: use official Maven/Gradle image to build the fat jar.
2. Runtime stage: use `eclipse-temurin` JRE or distroless and copy the jar.

Scan images with Trivy in CI and run smoke tests against the produced image before publishing.

---

## CI/CD recommendations

Suggested pipeline (GitHub Actions or equivalent):

1. **PR checks** — format, linters, unit tests, static analysis.
2. **Integration** — integration tests in merge pipeline or nightly.
3. **Artifact build** — produce fat jar and tarballs; generate checksums and sign artifacts.
4. **Security** — run dependency vulnerability checks and image scans.
5. **Release** — publish to GitHub Releases and optionally push container images to a registry.

Pin JDK versions and build tool versions in CI for reproducible builds.

---

## Contributing

Contributions welcome. Suggested workflow:

1. Fork the repository and create a descriptive branch.
2. Run formatting & linting locally and add unit tests for new behavior.
3. Open a PR and reference relevant `TASKS.md` items.
4. Ensure CI passes and address review comments.

Please follow existing style and include tests for changes that modify behavior.

---

## License

This template ships under the Apache-2.0 license. See the `LICENSE` file for details.
